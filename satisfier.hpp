#ifndef SATISFIER_HPP
#define SATISFIER_HPP

#include <stdbool.h>

#if defined(_WIN32) || defined(__CYGWIN__)
  #ifdef BUILD_SATISFIER
    #define SATISFIER_API __declspec(dllexport)
  #else
    #define SATISFIER_API __declspec(dllimport)
  #endif
#else
  #ifdef BUILD_SATISFIER
    #define SATISFIER_API __attribute__((visibility("default")))
  #else
    #define SATISFIER_API
  #endif
#endif

#ifdef __cplusplus
extern "C" {
    // Opaque forward declaration
    struct Logic;

    // Core C API: creation, deletion, binary AND, OR, NOT, and value access
    SATISFIER_API struct Logic* internal_new_logic(bool initial_value, const char* name);
    SATISFIER_API void          internal_delete_logic(struct Logic* instance);
    SATISFIER_API struct Logic* internal_and(const struct Logic* left,
                                             const struct Logic* right);
    SATISFIER_API struct Logic* internal_or (const struct Logic* left,
                                             const struct Logic* right);
    SATISFIER_API struct Logic* internal_not(const struct Logic* left,
                                             const struct Logic* right);
    SATISFIER_API bool          internal_logic_value(const struct Logic* instance);
}

#include <utility>

namespace sat {

/// C++ RAII wrapper enabling two operand logic chaining
class Logic {
    private:
    ::Logic* ptr_;
    explicit Logic(::Logic* p) : ptr_(p) {}

    public:
    // construct from bool
    Logic(bool value, const char* name)
      : ptr_( internal_new_logic(value, name)) {}

    // copy
     Logic(const Logic& o)
      : ptr_( internal_new_logic(o.value(), nullptr) ) {}

    // move
    Logic(Logic&& o) noexcept : ptr_(o.ptr_) { o.ptr_ = nullptr; }

    // destructor
    ~Logic() {
        if (ptr_) internal_delete_logic(ptr_);
    }

    // assignment by copy and swap
    Logic& operator=(Logic o) noexcept {
        std::swap(ptr_, o.ptr_);
        return *this;
    }

    // two operand AND: prints warning if left is false, then computes both
    Logic And(const Logic& rhs) const {
        return Logic( internal_and(ptr_, rhs.ptr_), nullptr);
    }

    // two operand OR: conventional OR over both operands
    Logic Or(const Logic& rhs) const {
        return Logic( internal_or(ptr_, rhs.ptr_), nullptr);
    }

    // unary NOT: uses C API
    Logic Not(const Logic& rhs) const {
        return Logic( internal_not(ptr_, rhs.ptr_), nullptr);
    }

    // extract boolean value
    bool value() const {
        return internal_logic_value(ptr_);
    }
};

#define DEFINE_VARIABLE(var, val) sat::Logic var((val), #var)

} // namespace sat
#endif // __cplusplus

#endif // SATISFIER_HPP
